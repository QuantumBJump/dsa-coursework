\documentclass{report}
%package definitions
\usepackage{listings}
\usepackage{courier}
\usepackage{lipsum}
\usepackage{pgfplots}
\usepackage{filecontents}

%setup for pgfplots
\pgfplotsset{compat=1.9}

%title
\author{Quinn Stevens}
\title{Investigating the Relative Efficiency of Different Sorting Algorithms}

%setting up listing formatting
\lstdefinestyle{mystyle}{
	breaklines=true,
	keepspaces=true,
	basicstyle=\footnotesize\ttfamily
}
\lstset{style=mystyle}

\begin{document}
\maketitle

\section*{Executive Summary}
This report compares and contrasts the time efficiency of the Bubble Sort, Insertion Sort and Merge Sort algorithms, and contains an appendix with pseudocode for a function to segregate even and odd numbers in an array.

\tableofcontents

\chapter{Setting up Sort\textunderscore Tester.java}
In order to set up the testing, I first added the following code to allow the user to define the size of the random array to generate.

\begin{lstlisting}[language=java, caption=Accepting user input]
import java.util.Scanner;
...
Scanner scanner = new Scanner(System.in);
System.out.println("How big is your array?");
int arraySize = scanner.nextInt();
\end{lstlisting}

Then I generated a random array of that size using:

\begin{lstlisting}[language=java, caption=Generating the randomised array]
import java.util.Random;
...
int[] arr = new int[arraySize];
Random random = new Random();
for (int i = 0; i < arrayLength; i++) {
    arr[i] = random.nextInt(50);
}
\end{lstlisting}

Before running each test, I copied the generated randomised array into a second array, \texttt{toBeSorted}, so I could sort that array without affecting the original array. This meant that each algorithm was operating on the same dataset, which meant the test was fairer.

I then noted the start time, called the algorithm on \texttt{toBeSorted}, noted the finish time and worked out the time elapsed in nanoseconds using \texttt{System.nanoTime()}.



\chapter{Implementing Quicksort}

I decided that the fourth sorting algorithm I would implement would be Quick Sort. The code I used to implement that sorting algorithm was:

\begin{lstlisting}[language=java, caption=Quicksort implementation]
public static void quickSort(int[] inputArray, int low, int high) {
    if (inputArray == null || inputArray.length == 0) {
        return;
    }
    if (low >= high) {
        return;
    }

    //pick pivot
    int middle = low + (high - low) / 2;
    int pivot = inputArray[middle];

    // make left < pivot and right > pivot
    int i = low, j = high;
    while (i <= j) {
        while(inputArray[i] < pivot) {
            i++;
        }
        while(inputArray[j] > pivot) {
            j--;
        }

        if (i <= j) {
            int temp = inputArray[i];
            inputArray[i] = inputArray[j];
            inputArray[j] = temp;
            i++;
            j--;
        }
    }

    // recursively sort two subarrays
    if (low < j) {
        quickSort(inputArray, low, j);
    }
    if (high > i) {
        quickSort(inputArray, i, high);
    }
}
\end{lstlisting}

\chapter{Comparing Time Complexity}


\begin{tikzpicture}
  \begin{axis} [
    title={Plotting time taken to sort different size arrays},
    xlabel={Size of array},
    ylabel={Time taken to sort}
    ]
    \addplot[color=red] table[x=array size,y=bubble sort, col sep=comma] {results.csv};
    \addplot[color=orange] table[x=array size, y=insertion sort, col sep=comma] {results.csv};
    \addplot[color=blue] table[x=array size, y=merge sort, col sep=comma] {results.csv};
    \addplot[color=green] table[x=array size, y=quick sort, col sep=comma] {results.csv};
  \end{axis}
\end{tikzpicture}

\chapter{Discussing Time Complexity}

\addcontentsline{toc}{chapter}{Appendix 1: Segregating Odd and Even Numbers}
\chapter*{Appendix 1: Segregating Odd and Even Numbers}

\end{document}
